:PROPERTIES:
:MODIFIED: <2022-08-17 Wed 06:37>
:END:
#+title: Doom Emacs Configuration
#+subtitle: Doom.
#+author: pard68
#+html_head: <link rel='shortcut icon' type='image/png' href='https://www.gnu.org/software/emacs/favicon.png'>
#+property: header-args:emacs-lisp :tangle yes :comments link
#+property: header-args:elisp :exports code
#+property: header-args:shell :tangle "setup.sh"
#+property: header-args :tangle no :results silent :eval no-export
#+options: coverpage:yes
#+startup: fold

* General Settings
** Bootstrappin'

For some reason =lexical-binding= makes things faster. Let's initialize all our files with this at the top.

Here's =config.el='s
#+begin_src emacs-lisp
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-
;; DO NOT EDIT THIS FILE DIRECTLY
;; This is a file generated from a literate programing source file located at
;; `$HOME/.config/doom/config.org`. You should make any changes there and
;; regenerate it from Emacs org-mode using org-babel-tangle (C-c C-v t)
#+end_src

Here's =init.el='s
#+begin_src emacs-lisp :tangle "init.el" :noweb no-export :comments no
;;; init.el -*- lexical-binding: t; -*-
;; DO NOT EDIT THIS FILE DIRECTLY
;; This is a file generated from a literate programing source file located at
;; `$HOME/.config/doom/config.org`. You should make any changes there and
;; regenerate it from Emacs org-mode using org-babel-tangle (C-c C-v t)
#+end_src

Here's =packages.el='s
#+begin_src emacs-lisp :tangle "packages.el"
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el
;; DO NOT EDIT THIS FILE DIRECTLY
;; This is a file generated from a literate programing source file located at
;; `$HOME/.config/doom/config.org`. You should make any changes there and
;; regenerate it from Emacs org-mode using org-babel-tangle (C-c C-v t)
#+end_src

And this means we don't have to wait for Emacs to recompile our config on each save.
#+begin_src emacs-lisp
(remove-hook 'org-mode-hook #'+literate-enable-recompile-h)
#+end_src

** Personal Info
#+begin_src emacs-lisp
(setq user-full-name "Ian S. Pringle"
      user-mail-address "ian@dapringles.com"
      auth-sources '("~/.authinfo"))

#+end_src

** A E S T H E T I C
*** Fonts
#+begin_src emacs-lisp :tangle no
(setq doom-font (font-spec :family "Overpass Nerd Font Mono" :size 24)
      doom-big-font (font-spec :family "Overpass Nerd Font Mono" :size 36)
      doom-variable-pitch-font (font-spec :family "Overpass Nerd Font" :size 24)
      doom-unicode-font (font-spec :family "Overpass Nerd Font Mono")
      doom-serif-font (font-spec :family "Overpass Nerd Font Mono" :weight 'light))
#+end_src

In addition to these fonts, Merriweather is used with =nov.el=, and Alegreya as a
serifed proportional font used by =mixed-pitch-mode= for =writeroom-mode= with Org
files.

If fonts are missing on the system, after Doom's UI has initialized, a warning
listing the missing fonts should appear for at least half a second.
#+name: detect-missing-fonts
#+begin_src emacs-lisp :tangle no
(defvar required-fonts '("Overpass Nerd Font" "Overpass Nerd Font Mono" "Merriweather" "Alegreya"))

(defvar available-fonts
  (delete-dups (or (font-family-list)
                   (split-string (shell-command-to-string "fc-list : family")
                                 "[,\n]"))))

(defvar missing-fonts
  (delq nil (mapcar
             (lambda (font)
               (unless (delq nil (mapcar (lambda (f)
                                           (string-match-p (format "^%s$" font) f))
                                         available-fonts))
                 font))
             required-fonts)))

(if missing-fonts
    (pp-to-string
     `(unless noninteractive
        (add-hook! 'doom-init-ui-hook
          (run-at-time nil nil
                       (lambda ()
                         (message "%s missing the following fonts: %s"
                                  (propertize "Warning!" 'face '(bold warning))
                                  (mapconcat (lambda (font)
                                               (propertize font 'face 'font-lock-variable-name-face))
                                             ',missing-fonts
                                             ", "))
                         (sleep-for 0.5))))))
  ";; No missing fonts detected")
#+end_src

#+begin_src emacs-lisp :noweb no-export :tangle no
<<detect-missing-fonts()>>
#+end_src

*** Theme
#+begin_src emacs-lisp
(setq doom-theme 'doom-nord-light)
(remove-hook 'window-setup-hook #'doom-init-theme-h)
(add-hook 'after-init-hook #'doom-init-theme-h 'append)
(delq! t custom-theme-load-path)
#+end_src
*** Dashboard
:PROPERTIES:
:MODIFIED: <2022-08-17 Wed 06:11>
:END:

Set the splash image:
#+begin_src emacs-lisp
(setq fancy-splash-image (expand-file-name "assets/blackhole-doodle.svg" doom-user-dir))
#+end_src

Add an ASCII fallback logo:
#+begin_src emacs-lisp
(defun doom-dashboard-draw-ascii-emacs-banner-fn ()
  (let* ((banner
          '(",---.,-.-.,---.,---.,---."
            "|---'| | |,---||    `---."
            "`---'` ' '`---^`---'`---'"))
         (longest-line (apply #'max (mapcar #'length banner))))
    (put-text-property
     (point)
     (dolist (line banner (point))
       (insert (+doom-dashboard--center
                +doom-dashboard--width
                (concat
                 line (make-string (max 0 (- longest-line (length line)))
                                   32)))
               "\n"))
     'face 'doom-dashboard-banner)))

(unless (display-graphic-p) ; for some reason this messes up the graphical splash screen atm
  (setq +doom-dashboard-ascii-banner-fn #'doom-dashboard-draw-ascii-emacs-banner-fn))
#+end_src

Declutter the dashboard:
#+begin_src emacs-lisp
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-shortmenu)
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-footer)
(add-hook! '+doom-dashboard-mode-hook (hide-mode-line-mode 1) (hl-line-mode -1))
(setq-hook! '+doom-dashboard-mode-hook evil-normal-state-cursor (list nil))
#+end_src

** Misc.
*** Allow babel execution in CLI actions
The =$DOOMDIR/cli.el= file is sourced every time a CLI command is run, so we can just enable evaluation by setting ~org-confirm-babel-evaluate~ to ~nil~ there. While we're at it, we should silence ~org-babel-execute-src-block~ to avoid polluting the output.

#+begin_src emacs-lisp :tangle cli.el :comments no
;;; cli.el -*- lexical-binding: t; -*-
(setq org-confirm-babel-evaluate nil)

(defun doom-shut-up-a (orig-fn &rest args)
  (quiet! (apply orig-fn args)))

(advice-add 'org-babel-execute-src-block :around #'doom-shut-up-a)
#+end_src

*** Asynchronous config tangling
This rewrites Doom's org-mode hook to be async. If my literate config ever gets
too complicated, this might need to be reevaluated.
#+begin_src emacs-lisp
(defadvice! +literate-tangle-async-h ()
  "A very simplified version of `+literate-tangle-h', but async."
  :override #'+literate-tangle-h
  (let ((default-directory doom-user-dir))
    (async-shell-command
     (format "emacs --batch --eval \"(progn \
(require 'org) (setq org-confirm-babel-evaluate nil) \
(org-babel-tangle-file \\\"%s\\\"))\""
             +literate-config-file))))
#+end_src

*** Preserve indentation when tangling
#+begin_src emacs-lisp
(setq org-src-preserve-indentation t)
#+end_src
*** Key Mappings
#+begin_src emacs-lisp
(map! :leader
      (:prefix "o"
       :desc "Open ielm" "I" #'ielm))
#+end_src
* Doom's =init.el=
** init.el boilerplate
#+name: init.el
#+attr_html: :collapsed t
#+begin_src emacs-lisp :tangle "init.el" :noweb no-export :comments no
(doom! :completion
       <<doom-completion>>

       :ui
       <<doom-ui>>

       :editor
       <<doom-editor>>

       :emacs
       <<doom-emacs>>

       :term
       <<doom-term>>

       :checkers
       <<doom-checkers>>

       :tools
       <<doom-tools>>

       :os
       <<doom-os>>

       :lang
       <<doom-lang>>

       :email
       <<doom-email>>

       :app
       <<doom-app>>

       :config
       <<doom-config>>
       )
#+end_src

** Doom Completion
#+name: doom-completion
#+begin_src emacs-lisp :tangle no
       company
       (vertico +icons)
#+end_src

** Doom UI
#+name: doom-ui
#+begin_src emacs-lisp :tangle no
       deft
       doom
       doom-dashboard
       doom-quit
       (emoji +unicode)
       fill-column
       hl-todo
       (ligatures +extra)
       minimap
       modeline
       nav-flash
       ophints
       (popup +all +defaults)
       tabs
       treemacs
       unicode
       vc-gutter
       vi-tilde-fringe
       (window-select +numbers)
       workspaces
#+end_src

** Doom Editor
#+name: doom-editor
#+begin_src emacs-lisp :tangle no
       (evil +everywhere)
       file-templates
       fold
       (format +onsave)
       rotate-text
       snippets
       word-wrap
#+end_src

** Doom Emacs
#+name: doom-emacs
#+begin_src emacs-lisp :tangle no
       (dired +icons +ranger)
       electric
       (ibuffer +icons)
       (undo +tree)
       vc
#+end_src

** Doom Term
#+name: doom-term
#+begin_src emacs-lisp :tangle no
       eshell
       vterm
#+end_src

** Doom Checkers
#+name: doom-checkers
#+begin_src emacs-lisp :tangle no
       syntax
       (spell +flyspell)
#+end_src

** Doom Tools
#+name: doom-tools
#+begin_src emacs-lisp :tangle no
       ansible
       docker
       (eval +overlay)
       (lookup
        +dictionary
        +docsets
        +offline)
       (lsp +peek)
       (magit +forge)
       make
       (pass +auth)
       pdf
       rgb
       ;; terraform
       tree-sitter
       ;; tmux
       upload
#+end_src

** Doom OS
#+name: doom-os
#+begin_src emacs-lisp :tangle no
       (:if IS-MAC macos)
       tty
#+end_src

** Doom Langs
#+name: doom-lang
#+begin_src emacs-lisp :tangle no
       common-lisp
       (clojure +lsp)
       data
       emacs-lisp
       (go +lsp +tree-sitter)
       (graphql +lsp)
       ;; (haskell +lsp)
       (json +lsp +tree-sitter)
       (javascript +lsp +tree-sitter)
       (latex +lsp)
       ledger
       (lua +fennel +lsp +moonscript)
       markdown
       (org
        +present
        +noter
        +dragndrop
        +pomodoro
        +pretty
        +roam2)
       (python +lsp +poetry +pyenv +tree-sitter)
       (racket +lsp +xp)
       (rest +jq)
       (rust +lsp)
       (sh +lsp)
       (web +lsp +tree-sitter)
       (yaml +lsp)
#+end_src

** Doom Email
#+name: doom-email
#+begin_src emacs-lisp :tangle no
       (mu4e +gmail +org)
       ;; (notmuch +afew +org)
#+end_src

** Doom Apps
#+name: doom-app
#+begin_src emacs-lisp :tangle no
       calendar
       everywhere
       (rss +org)
#+end_src

** Doom Config
#+name: doom-config
#+begin_src emacs-lisp :tangle no
       literate
       (default +bindings +smartparens)
#+end_src
* Email
To get the auth-sources stuff working on MacOS we have to:
#+begin_src emacs-lisp
(after! auth-source
  (setq auth-sources (nreverse auth-sources)))
#+end_src
** notmuch
*** General settings
#+begin_src emacs-lisp :tangle no
(setq +notmuch-sync-backend 'mbsync-xdg)
#+end_src
** mu4e
*** General settings
#+begin_src emacs-lisp
(setq mu4e-get-mail-command "mbsync -c ~/.config/isync/mbsyncrc -a"
      mu4e-update-interval 300
      mu4e-compose-format-flowed t
      mu4e-header-date-format "%y-%m-%d")
#+end_src
*** Personal Accounts
**** ipringle@protonmail.com
#+begin_src emacs-lisp
(set-email-account! "protonmail"
    '((user-mail-address      . "ipringle@protonmail.com")
      (mu4e-sent-folder       . "/ipringle@protonmail.com/Sent")
      (mu4e-drafts-folder     . "/ipringle@protonmail.com/Drafts")
      (mu4e-trash-folder      . "/ipringle@protonmail.com/Trash")
      (mu4e-refile-folder     . "/ipringle@protonmail.com/Archive")
      (mu4e-compose-signature . "---\nFrom\nIan S. Pringle")
      (smtpmail-smtp-user     . "ipringle@protonmail.com")
      (smtpmail-smtp-server   . "127.0.0.1")
      (smtpmail-smtp-service  . 1025))
    nil)
#+end_src
**** pard@0x44.pw
#+begin_src emacs-lisp
(set-email-account! "0x44"
    '((user-mail-address      . "pard@0x44.pw")
      (mu4e-sent-folder       . "/pard@0x44.pw/Sent")
      (mu4e-drafts-folder     . "/pard@0x44.pw/Drafts")
      (mu4e-trash-folder      . "/pard@0x44.pw/Trash")
      (mu4e-refile-folder     . "/pard@0x44.pw/Archive")
      (mu4e-compose-signature . "---\nFrom\nIan S. Pringle")
      (smtpmail-smtp-user     . "pard@0x44.pw")
      (smtpmail-smtp-server   . "127.0.0.1")
      (smtpmail-smtp-service  . 1025))
    nil)
#+end_src
**** ian@dapringles.com
#+begin_src emacs-lisp
(set-email-account! "dapringles"
    '((user-mail-address      . "ian@dapringles.com")
      (mu4e-sent-folder       . "/ian@dapringles.com/Sent")
      (mu4e-drafts-folder     . "/ian@dapringles.com/Drafts")
      (mu4e-trash-folder      . "/ian@dapringles.com/Trash")
      (mu4e-refile-folder     . "/ian@dapringles.com/Archive")
      (mu4e-compose-signature . "---\nFrom\nIan S. Pringle")
      (smtpmail-smtp-user     . "ian@dapringles.com")
      (smtpmail-smtp-server   . "127.0.0.1")
      (smtpmail-smtp-service  . 1025))
    t)
#+end_src
*** Work Account
#+begin_src emacs-lisp
(set-email-account! "work"
    '((user-mail-address      . "i.pringle@hbhold.com")
      (mu4e-sent-folder       . "/ipringle@hbhold.com/Sent Items")
      (mu4e-drafts-folder     . "/ipringle@hbhold.com/Drafts")
      (mu4e-trash-folder      . "/ipringle@hbhold.com/Deleted Items")
      (mu4e-refile-folder     . "/ipringle@hbhold.com/Archive")
      (mu4e-compose-signature . "---\nFrom\nIan S. Pringle")
      (smtpmail-smtp-user     . "i.pringle@hbhold.com")
      (smtpmail-smtp-server   . "outlook.office.com")
      (smtpmail-smtp-service  . 587))
    nil)
#+end_src

* Orgmode
*** Settings
**** Boilerplate
Let's add auto save to org buffers.
#+begin_src emacs-lisp
;;(add-hook 'auto-save-hook 'org-save-all-org-buffers)
#+end_src

Now to fix some defaults:

#+begin_src emacs-lisp
(setq org-use-property-inheritance t
      org-log-done 'time
      org-list-allow-alphabetical t
      org-export-in-background t
      org-fold-catch-invisible-edits 'smart)
#+end_src
**** Auto Save and Sync

One minute before the start of the next hour, save all org buffers.

#+begin_src emacs-lisp
(run-at-time "00:59" 3600 'org-save-all-org-buffers)
#+end_src

And then just used the baked in git sync feature:
#+begin_src emacs-lisp
(require 'org-attach-git)
#+end_src

**** Org Directories
#+begin_src emacs-lisp
;; Much of my org setup was stolen from http://doc.norang.ca/org-mode.html
(after! org-agenda
    (setq
     org-notes (concat (getenv "HOME") "/org")
     org-directory org-notes
     deft-directory org-notes
     org-roam-directory (concat org-notes "/grok")
     org-roam-dailies-directory org-notes
     +org-capture-inbox (concat org-notes "/life.org")
     +org-capture-weekly (concat org-notes "/weekly.org")
     org-agenda-files (apply 'append
                             (mapcar
                              (lambda (directory)
                                (directory-files-recursively
                                 directory org-agenda-file-regexp))
                              (list org-notes )))))
#+end_src

**** Org Keywords

The idea here is the minimize states, which minimizes the time I have to think
about the state task should be in. Ultimately tasks either need to be started
(TODO), are finished (DONE), or cannot be worked on (HOLD). The idea of a "NEXT"
is better off-loaded to some algorithm that can determine the /next best/ task
to work on based on the effort required to finish it, the priority of the task,
and whether it's a blocker for another task. This is how Taskwarrior does it,
and think this is a great thing to embrace. The KILL state is here mostly
because it's a almost zero-effort call on whether or not a task is KILL'd (ie no
longer needs to be moved to a DONE state) and KILL'd, or cancelled, task is
different enough from a DONE task to merit it's own face..

Appointments (APPT) are like TODOs that are in HOLD until a specific time and at
the appointed time are immediately the /active/ task, until completed, when they
immediately are DONE. I mostly added this APPT state so that I can easily see
when I have appointments and because, like KILL, it requires next to no energy
to know if a task is an APPT -- and in fact this face would likely almost only
ever been created through a capture template anyway.

Finally we have the last three faces -- I don't want to use 'state' for them
because they're really not even tasks. MEET is for, wait for it, meetings -- but
also other similar types of events. The goal with MEET is to open the capture
template, keep it open for the duration of the MEET-thing and then close it. The
opening of the MEET-thing would log the start time and then the closing would
log the close. Why do I have NOTE and IDEA? No clue, I should probably just keep
one or the other, but I /feel/ like there is enough difference between the two
concepts to warrant both. An IDEA is something to /explore in detail later/,
like a blog post or a topic to look into. A NOTE is some knowledge or inkling I
want to /retain/ and perhaps develop later into a /grok/. Time will tell if I
keep both faces or condense them into one.

Lastly, I have some faces for my reading list. I was controlling this with a
file variable but it wasn't working right and it doesn't hurt anything to put
this in here.

#+CAPTION: Task State Workflow
#+NAME: Normal Task Workflow
[[file:normal_task_states.png]]
#+begin_src emacs-lisp
(after! org
  (setq org-todo-keywords
      '(
        (sequence "TODO(t)" "|" "DONE(d!/!)")
        (sequence "HOLD(h@/!)" "|" "KILL(k@/!)")
        (sequence "APPT(a)" "|" "DONE(d!)")
        (sequence "MEET(m)" "IDEA(i)" "NOTE(n)")
        (sequence "READ(r)" "READING(R)" "|" "DONE(d@/!)")))

  (setq org-todo-keyword-faces
        '(
          ;; I like the default TODO color...
          ;; ("TODO" :foreground "red" :weight bold)
          ("DONE" :foreground "forest green" :weight bold)
          ("HOLD" :foreground "magenta" :weight bold)
          ("KILL" :foreground "forest green" :weight bold)
          ("MEET" :foreground "forest green" :weight bold)
          ("APPT" :foreground "magenta" :weight bold)
          ("IDEA" :foreground "gold" :weight bold)
          ("NOTE" :foreground "blue" :weight bold)
          ("READ" :foreground "red" :weight bold)
          ("READING" :foreground "magenta" :weight bold)))

  (setq org-use-fast-todo-selection t)
  (setq org-treat-S-cursor-todo-selection-as-state-change nil)
  (setq org-todo-state-tags-triggers
        '(("KILL" ("KILL" . t) ("ARCHIVE" . t))
          ("HOLD" ("HOLD" . t) ("ARCHIVE"))
          (done ("HOLD") ("ARCHIVE". t))
          ("TODO" ("HOLD") ("KILL") ("ARCHIVE"))
          ("DONE" ("HOLD") ("KILL") ("ARCHIVE" . t))
          ("READ" ("ARCHIVE"))
          ("READING" ("ARCHIVE")))))
#+end_src

**** Org tags
#+begin_src emacs-lisp
(after! org
  (setq org-tag-alist '(
                        ;; Related to the computer, but not specific to work
                        ("BLOG" . ?b)
                        ("ORG" . ?o)
                        ;; Related to work
                        ("@work" . ?w)
                        ("INCIDENT" . ?I)
                        ("REQUEST" . ?I)
                        ;; Related to IRL
                        ("@home" . ?h)
                        ("@farm" . ?f)
                        ;; Related to traveling
                        ("ERRAND" . ?e)
                        ("@Doniphan" . ?D)
                        ("@PoplarBluff" . ?P)
                        ("@WestPlain" . ?W)
                        ("@Thayer" . ?T)
                        )))
#+end_src

**** Org Capture Templates

I'm trying to keep everything to just one file. Or, at least most of everything.
So we file everything into the "Inbox" heading, which is the /holding/ tank for
almost all my captures so I can later go through them and evaluate if they're
really valuable or not. Capturing is for the purpose of getting all my ideas,
tasks, etc. out of my head and somewhere less ephemeral as quickly as possible.
We can review the merit of the /things/ that are captures later during a reivew
period.

#+begin_src emacs-lisp
  (setq org-capture-templates
        '(("t" "Task" entry (file+headline +org-capture-inbox "Inbox")
           "* TODO %? %(org-set-tags-command) \nCREATED: %U\n" :clock-in t :clock-resume t)
          ("i" "Ideas" entry (file+headline +org-capture-inbox "Inbox")
           "* IDEA %?\nCREATED: %U\n" :clock-in t :clock-resume t)
          ("n" "Notes" entry (file+headline +org-capture-inbox "Inbox")
           "* NOTE %?\nCREATED: %U\n" :clock-in t :clock-resume t)
          ("a" "Appointment" entry (file+headline +org-capture-inbox "Inbox")
           "* APPT %? %^T %^gAPPOINTMENT: \nCREATED: %U\n" :clock-in t :clock-resume t)
          ("m" "Meeting" entry (file+headline +org-capture-inbox "Meeting")
           "* MEET with %? :MEETING:\nCREATED: %U\n" :clock-in t :clock-resume t)
          ("w" "Weekly Plan" entry (file+olp+datetree +org-capture-weekly)
           "* Goals\n* Changes\n* PTO\n* Notes\n" :clock-in t :clock-resume t :tree-type week)
          ))
#+end_src

Because we are clocking all captures, we could easily end up with a 0:00 clock,
which we want to delete, but than that'd end up with an empty ~:LOGBOOK:~ and so
we should delete those since they're ugly and pointless.

#+begin_src emacs-lisp
(defun 0x44/remove-empty-drawer-on-clock-out ()
  (interactive)
  (save-excursion
    (beginning-of-line 0)
    (org-remove-empty-drawer-at (point))))

(add-hook 'org-clock-out-hook '0x44/remove-empty-drawer-on-clock-out 'append)

#+end_src

**** Org Clocking
#+begin_src emacs-lisp
;;
;; Resume clocking task when emacs is restarted
(org-clock-persistence-insinuate)
;;
;; Show lot of clocking history so it's easy to pick items off the C-F11 list
(setq org-clock-history-length 23)

;; Resume clocking task on clock-in if the clock is open
(setq org-clock-in-resume t)

;; Separate drawers for clocking and logs
(setq org-drawers (quote ("PROPERTIES" "LOGBOOK")))

;; Save clock data and state changes and notes in the LOGBOOK drawer
(setq org-clock-into-drawer t)

;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
(setq org-clock-out-remove-zero-time-clocks t)

;; Clock out when moving task to a done state
(setq org-clock-out-when-done t)

;; Save the running clock and all clock history when exiting Emacs, load it on startup
(setq org-clock-persist t)

;; Do not prompt to resume an active clock
(setq org-clock-persist-query-resume nil)

;; Enable auto clock resolution for finding open clocks
(setq org-clock-auto-clock-resolution (quote when-no-clock-is-running))

;; Include current clocking task in clock reports
(setq org-clock-report-include-clocking-task t)
#+end_src

***** Clocking functions stolen from Norang

[[http://doc.norang.ca/org-mode.html#Clocking][Source]]

#+begin_src emacs-lisp
(setq bh/keep-clock-running nil)

(defun bh/find-project-task ()
  "Move point to the parent (project) task if any"
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
      (while (org-up-heading-safe)
        (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
          (setq parent-task (point))))
      (goto-char parent-task)
      parent-task)))

(defun bh/punch-in (arg)
  "Start continuous clocking and set the default task to the
selected task.  If no task is selected set the Organization task
as the default task."
  (interactive "p")
  (setq bh/keep-clock-running t)
  (if (equal major-mode 'org-agenda-mode)
      ;;
      ;; We're in the agenda
      ;;
      (let* ((marker (org-get-at-bol 'org-hd-marker))
             (tags (org-with-point-at marker (org-get-tags-at))))
        (if (and (eq arg 4) tags)
            (org-agenda-clock-in '(16))
          (bh/clock-in-organization-task-as-default)))
    ;;
    ;; We are not in the agenda
    ;;
    (save-restriction
      (widen)
      ; Find the tags on the current task
      (if (and (equal major-mode 'org-mode) (not (org-before-first-heading-p)) (eq arg 4))
          (org-clock-in '(16))
        (bh/clock-in-organization-task-as-default)))))

(defun bh/punch-out ()
  (interactive)
  (setq bh/keep-clock-running nil)
  (when (org-clock-is-active)
    (org-clock-out))
  (org-agenda-remove-restriction-lock))

(defun bh/clock-in-default-task ()
  (save-excursion
    (org-with-point-at org-clock-default-task
      (org-clock-in))))

(defun bh/clock-in-parent-task ()
  "Move point to the parent (project) task if any and clock in"
  (let ((parent-task))
    (save-excursion
      (save-restriction
        (widen)
        (while (and (not parent-task) (org-up-heading-safe))
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq parent-task (point))))
        (if parent-task
            (org-with-point-at parent-task
              (org-clock-in))
          (when bh/keep-clock-running
            (bh/clock-in-default-task)))))))

(defvar bh/organization-task-id "0a6abfc7-3d86-4a11-8ed4-85154df397f8")

(defun bh/clock-in-organization-task-as-default ()
  (interactive)
  (org-with-point-at (org-id-find bh/organization-task-id 'marker)
    (org-clock-in '(16))))

(defun bh/clock-out-maybe ()
  (when (and bh/keep-clock-running
             (not org-clock-clocking-in)
             (marker-buffer org-clock-default-task)
             (not org-clock-resolving-clocks-due-to-idleness))
    (bh/clock-in-parent-task)))

(add-hook 'org-clock-out-hook 'bh/clock-out-maybe 'append)

(require 'org-id)
(defun bh/clock-in-task-by-id (id)
  "Clock in a task by id"
  (org-with-point-at (org-id-find id 'marker)
    (org-clock-in nil)))

(defun bh/clock-in-last-task (arg)
  "Clock in the interrupted task if there is one
Skip the default task and get the next one.
A prefix arg forces clock in of the default task."
  (interactive "p")
  (let ((clock-in-to-task
         (cond
          ((eq arg 4) org-clock-default-task)
          ((and (org-clock-is-active)
                (equal org-clock-default-task (cadr org-clock-history)))
           (caddr org-clock-history))
          ((org-clock-is-active) (cadr org-clock-history))
          ((equal org-clock-default-task (car org-clock-history)) (cadr org-clock-history))
          (t (car org-clock-history)))))
    (widen)
    (org-with-point-at clock-in-to-task
      (org-clock-in nil))))
#+end_src

****** Utility functions stolen fron Norang to help with the clocking functions stolen from Norang

#+begin_src emacs-lisp
(defun bh/is-project-p ()
  "Any task with a todo keyword subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task has-subtask))))

(defun bh/is-project-subtree-p ()
  "Any task with a todo keyword that is in a project subtree.
Callers of this function already widen the buffer view."
  (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                              (point))))
    (save-excursion
      (bh/find-project-task)
      (if (equal (point) task)
          nil
        t))))

(defun bh/is-task-p ()
  "Any task with a todo keyword and no subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task (not has-subtask)))))

(defun bh/is-subproject-p ()
  "Any task which is a subtask of another project"
  (let ((is-subproject)
        (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
    (save-excursion
      (while (and (not is-subproject) (org-up-heading-safe))
        (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
          (setq is-subproject t))))
    (and is-a-task is-subproject)))

(defun bh/list-sublevels-for-projects-indented ()
  "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
  This is normally used by skipping functions where this variable is already local to the agenda."
  (if (marker-buffer org-agenda-restrict-begin)
      (setq org-tags-match-list-sublevels 'indented)
    (setq org-tags-match-list-sublevels nil))
  nil)

(defun bh/list-sublevels-for-projects ()
  "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
  This is normally used by skipping functions where this variable is already local to the agenda."
  (if (marker-buffer org-agenda-restrict-begin)
      (setq org-tags-match-list-sublevels t)
    (setq org-tags-match-list-sublevels nil))
  nil)

(defvar bh/hide-scheduled-and-waiting-next-tasks t)

(defun bh/toggle-next-task-display ()
  (interactive)
  (setq bh/hide-scheduled-and-waiting-next-tasks (not bh/hide-scheduled-and-waiting-next-tasks))
  (when  (equal major-mode 'org-agenda-mode)
    (org-agenda-redo))
  (message "%s WAITING and SCHEDULED NEXT Tasks" (if bh/hide-scheduled-and-waiting-next-tasks "Hide" "Show")))

(defun bh/skip-stuck-projects ()
  "Skip trees that are not stuck projects"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (if (bh/is-project-p)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                 (has-next ))
            (save-excursion
              (forward-line 1)
              (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                (unless (member "WAITING" (org-get-tags-at))
                  (setq has-next t))))
            (if has-next
                nil
              next-headline)) ; a stuck project, has subtasks but no next task
        nil))))

(defun bh/skip-non-stuck-projects ()
  "Skip trees that are not stuck projects"
  ;; (bh/list-sublevels-for-projects-indented)
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (if (bh/is-project-p)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                 (has-next ))
            (save-excursion
              (forward-line 1)
              (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                (unless (member "WAITING" (org-get-tags-at))
                  (setq has-next t))))
            (if has-next
                next-headline
              nil)) ; a stuck project, has subtasks but no next task
        next-headline))))

(defun bh/skip-non-projects ()
  "Skip trees that are not projects"
  ;; (bh/list-sublevels-for-projects-indented)
  (if (save-excursion (bh/skip-non-stuck-projects))
      (save-restriction
        (widen)
        (let ((subtree-end (save-excursion (org-end-of-subtree t))))
          (cond
           ((bh/is-project-p)
            nil)
           ((and (bh/is-project-subtree-p) (not (bh/is-task-p)))
            nil)
           (t
            subtree-end))))
    (save-excursion (org-end-of-subtree t))))

(defun bh/skip-non-tasks ()
  "Show non-project tasks.
Skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((bh/is-task-p)
        nil)
       (t
        next-headline)))))

(defun bh/skip-project-trees-and-habits ()
  "Skip trees that are projects"
  (save-restriction
    (widen)
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((bh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       (t
        nil)))))

(defun bh/skip-projects-and-habits-and-single-tasks ()
  "Skip trees that are projects, tasks that are habits, single non-project tasks"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((org-is-habit-p)
        next-headline)
       ((and bh/hide-scheduled-and-waiting-next-tasks
             (member "WAITING" (org-get-tags-at)))
        next-headline)
       ((bh/is-project-p)
        next-headline)
       ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
        next-headline)
       (t
        nil)))))

(defun bh/skip-project-tasks-maybe ()
  "Show tasks related to the current restriction.
When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
When not restricted, skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
           (next-headline (save-excursion (or (outline-next-heading) (point-max))))
           (limit-to-project (marker-buffer org-agenda-restrict-begin)))
      (cond
       ((bh/is-project-p)
        next-headline)
       ((org-is-habit-p)
        subtree-end)
       ((and (not limit-to-project)
             (bh/is-project-subtree-p))
        subtree-end)
       ((and limit-to-project
             (bh/is-project-subtree-p)
             (member (org-get-todo-state) (list "NEXT")))
        subtree-end)
       (t
        nil)))))

(defun bh/skip-project-tasks ()
  "Show non-project tasks.
Skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((bh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       ((bh/is-project-subtree-p)
        subtree-end)
       (t
        nil)))))

(defun bh/skip-non-project-tasks ()
  "Show project tasks.
Skip project and sub-project tasks, habits, and loose non-project tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
           (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((bh/is-project-p)
        next-headline)
       ((org-is-habit-p)
        subtree-end)
       ((and (bh/is-project-subtree-p)
             (member (org-get-todo-state) (list "NEXT")))
        subtree-end)
       ((not (bh/is-project-subtree-p))
        subtree-end)
       (t
        nil)))))

(defun bh/skip-projects-and-habits ()
  "Skip trees that are projects and tasks that are habits"
  (save-restriction
    (widen)
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((bh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       (t
        nil)))))

(defun bh/skip-non-subprojects ()
  "Skip trees that are not projects"
  (let ((next-headline (save-excursion (outline-next-heading))))
    (if (bh/is-subproject-p)
        nil
      next-headline)))
#+end_src

*** Org Modules and Packages
**** org-super-agenda
#+begin_src emacs-lisp :tangle "packages.el"
;; (package! org-super-agenda)
#+end_src
#+begin_src emacs-lisp
;; (use-package! org-super-agenda
;;   :after org-agenda
;;   :config
;;   (setq org-super-agenda-groups '(
;;     (:name "Today" :date today)
;;     (:name "Inbox" :tag "INBOX")))
;;   (org-super-agenda-mode))
#+end_src
**** org-habits
Include the habit module for reoccuring tasks
#+begin_src emacs-lisp
(add-to-list 'org-modules 'org-habits)
#+end_src

**** org-pretty-table
Let's make org's tables look nicer.
#+begin_src emacs-lisp :tangle "packages.el"
(package! org-pretty-table :recipe (:host github :repo "Fuco1/org-pretty-table")
  :pin "7bd68b420d3402826fea16ee5099d04aa9879b78")
#+end_src
#+begin_src emacs-lisp
(use-package! org-pretty-table
  :commands (org-pretty-table-mode global-org-pretty-table-mode))
#+end_src

**** org-appear
Let's help org's =org-hide-emphasis-markers= work a little better.
#+begin_src emacs-lisp :tangle "packages.el"
(package! org-appear :recipe (:host github :repo "awth13/org-appear")
  :pin "8dd1e564153d8007ebc4bb4e14250bde84e26a34")
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! org-appear
  :hook (org-mode . org-appear-mode)
  :config
  (setq org-appear-autoemphasis t
        org-appear-autosubmarkers t
        org-appear-autolinks nil)
  ;; for proper first-time setup, `org-appear--set-elements'
  ;; needs to be run after other hooks have acted.
  (run-at-time nil nil #'org-appear--set-elements))
#+end_src

**** org-ol-tree
This makes org headings nicer.
#+begin_src emacs-lisp :tangle "packages.el"
(package! org-ol-tree :recipe (:host github :repo "Townk/org-ol-tree")
  :pin "207c748aa5fea8626be619e8c55bdb1c16118c25")
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! org-ol-tree
  :commands org-ol-tree
  :config
  (defadvice! org-ol-tree-system--graphical-frame-p--pgtk ()
    :override #'org-ol-tree-system--graphical-frame-p
    (memq window-system '(pgtk x w32 ns))))

(map! :map org-mode-map
      :after org
      :localleader
      :desc "Outline" "O" #'org-ol-tree)
#+end_src

**** org-chef
Capture recipes from urls!!!
#+begin_src emacs-lisp :tangle "packages.el"
(package! org-chef :pin "a97232b4706869ecae16a1352487a99bc3cf97af")
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! org-chef
  :commands (org-chef-insert-recipe org-chef-get-recipe-from-url))
#+end_src
**** org-timeline
Blocked time view for org-agenda
#+begin_src emacs-lisp :tangle "packages.el"
(package! org-timeline)
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! org-timeline)
(after! org-agenda
  (add-hook 'org-agenda-finalize-hook 'org-timeline-insert-timeline :append))
#+end_src

**** org-roam
#+begin_src emacs-lisp :tangle yes
(after! org-roam
  (setq org-roam-db-gc-threshold most-positive-fixnum
        org-link-to-org-use-id t)
  (set-popup-rules!
    `((,(regexp-quote org-roam-buffer) ; persistent org-roam buffer
       :side right :width .33 :height .5 :ttl nil :modeline nil :quit nil :slot 1)
      ("^\\*org-roam: " ; node dedicated org-roam buffer
       :side right :width .33 :height .5 :ttl nil :modeline nil :quit nil :slot 2)))
  (add-hook 'org-roam-mode-hook #'turn-on-visual-line-mode)
  (setq org-roam-capture-templates
        '(("d" "default" plain "%?"
           :if-new (file+head "${slug}.org"
                              "#+title: ${title}\n")
           :immediate-finish t
           :unnarrowed t)
          ("r" "bibliography reference" plain "%?"
           :if-new
           (file+head "references/${citekey}.org" "#+title: ${title}\n")
           :unnarrowed t)))
  (set-company-backend! 'org-mode '(company-capf))
  (require 'org-roam-protocol))
(use-package! org-roam-dailies
  :init
  (map! :leader
        :desc "org-roam-dailies-capture-today" "j" #'org-roam-dailies-capture-today)
  :config
  (setq org-roam-dailies-capture-templates
                '(("d" "day" entry
                   "* %<%I:%M %p>:\n%?"
                   :target (file+datetree "journal.org" day))
                  ("w" "week" entry
                   "* %?"
                   :target (file+datetree "weekly.org" week))
                  ("m" "month" entry
                   "* %?"
                   :target (file+datetree "monthly.org" month)))))
(use-package! org-roam-protocol
  :after org-protocol)
#+end_src

**** org-roam-ui
#+begin_src emacs-lisp :tangle "packages.el"
(package! websocket)
(package! org-roam-ui :recipe
  (:host github :repo "org-roam/org-roam-ui" :files ("*.el" "out")))
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! websocket
  :after org-roam)
(use-package! org-roam-ui
  :after org-roam
  :commands org-roam-ui-mode
  :config
  (setq org-roam-ui-sync-theme t
        org-roam-ui-port 35900
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start nil))
#+end_src

**** org-ref
#+begin_src emacs-lisp :tangle "packages.el"
;; (use-package! org-ref
;;   :defer t
;;   :config
;;   )
#+end_src
#+begin_src emacs-lisp :tangle yes
;; (after! org-ref
;;   (setq org-ref-default-bibliography `,(list (concat org-roam-directory "works.bib"))))
#+end_src

**** org-roam-bibtex
#+begin_src emacs-lisp :tangle "packages.el"
;; (package! org-roam-bibtex)
#+end_src
#+begin_src emacs-lisp :tangle yes
;; (use-package! org-roam-bibtex
;;   :after org-roam
;;   :config
;;   (require 'org-ref))
#+end_src


**** org-books
#+begin_src emacs-lisp :tangle "packages.el"
;; (package! org-books)
#+end_src
#+begin_src emacs-lisp :tangle yes
;; (use-package! org-books
;;   :after org-mode
;;   :config
;;   (require 'org-books)
;;   (setq org-books-file (concat org-notes + "books.org")))
#+end_src
*** Misc.
**** elfeed-org update
This is a function to update elfeed with new feeds in my elfeed-org file. I
found this [[https://blog.sidhartharya.com/automatically-fetching-newly-added-feeds-in-elfeed-org-file/][here]].
#+begin_src emacs-lisp
(require 'dash)
(defun 0x44/elfeed-org-update ()
  "Automatically update elfeed feeds from elfeed.org"
  (setq +elfeed-org-last (or (and (boundp 'elfeed-feeds) elfeed-feeds) nil))
  ;; (elfeed)
  (setq +elfeed-org-current elfeed-feeds)
  (let ((elfeed-feeds (-difference +elfeed-org-current +elfeed-org-last)))
    ;; (message "&s" elfeed-feeds)
    (mapc #'elfeed-update-feed (elfeed--shuffle (elfeed-feed-list))))
  (setq elfeed-feeds +elfeed-org-current))
#+end_src
**** Blog Templates

This function will create a new blog post from a "template".
#+begin_src emacs-lisp
(defun 0x44/create-new-blog-buffer ()
  "Created a new blog from the specified template in a new buffer"
  (interactive)
  (let (($timestamp (format-time-string "<%Y-%m-%d %a %H:%M>" )))
    (let (($buf (generate-new-buffer "Untitled Blog Post")))
        (switch-to-buffer $buf)
        (insert (format ":PROPERTIES:\n:AUTHOR: %s\n:CREATED: %s\n:MODIFIED: %s\n:TYPE: blog\n:END:\n#+title: "
                user-full-name $timestamp $timestamp))
        (funcall 'org-mode)
        (setq buffer-offer-save t)
  $buf)))
#+end_src

**** Update MODIFIED property on save

Because of [[https://github.com/pard68/sylvan][Sylvan]], I like to keep a ~MODIFIED~ value in my properties drawer on most/all org files. It's also just handy to have this data available. To get this done, I use the following:
#+begin_src emacs-lisp
(defun 0x44/update-org-modified-property ()
  (save-excursion
    (goto-char (point-min))
    (when (re-search-forward "^:MODIFIED:" nil t)
      (org-entry-put (point-min) "MODIFIED"
                     (format-time-string " <%Y-%m-%d %a %H:%M>")))))
#+end_src

Then to hook this in so it is triggered on a save:
#+begin_src emacs-lisp
(defun 0x44/org-mode-before-save-hook ()
  (when (eq major-mode 'org-mode)
    (0x44/update-org-modified-property)))

(add-hook 'before-save-hook #'0x44/org-mode-before-save-hook)
#+end_src

**** Archive items
This is my stop-gap. But it flattens the structure and hides potentially valuable metadata...
#+begin_src emacs-lisp :tangle yes
(after! org-agenda
  (setq org-archive-mark-done nil
        org-archive-location "%s_archive::* Archived Tasks")

  (defun 0x44/skip-non-archivable-items ()
    "Skip trees that cannot be archieved"
    (save-restriction
        (widen)
        (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
            (subtree-end (save-excursion (org-end-of-subtree t))))
        (if (member (org-get-todo-state) org-todo-keywords-1)
            (if (member (org-get-todo-state) org-done-keywords)
                (let* ((daynr (string-to-int (format-time-string "%d" (current-time))))
                        (a-month-ago (* 60 60 24 (+ daynr 1)))
                        (last-month (format-time-string "%Y-%m-"
                                                        (time-subtract (current-time)
                                                                       (seconds-to-time a-month-ago))))
                        (this-month (format-time-string "%Y-%m-" (current-time)))
                        (subtree-is-current (save-excursion
                                            (forward-line 1)
                                            (and (< (point) subtree-end)
                                                    (re-search-forward (concat
                                                                        last-month
                                                                        "\\|"
                                                                        this-month)
                                                                       subtree-end t)))))
                    (if subtree-is-current
                        subtree-end ; Has a date in this month or last month, skip it
                    nil))  ; available to archive
                (or subtree-end (point-max)))
            next-headline)))))
#+end_src


When I archive an item I want to mimic the project tree to the archive file,
there is meaning in the tree and if we archive without copying the tree that archived item loses meaning.
However right now I cannot figure it out and I don't have the time. This sorta works, but not well
enough to use it...
#+begin_src emacs-lisp :tangle yes
(defun 0x44/crawl-project-tree ()
         (setq project-tree (list (nth 4 (org-heading-components))))
         (save-excursion
            (while (org-up-heading-safe)
                (setq project-tree (append (list (nth 4 (org-heading-components))) project-tree))))
         project-tree)

(defun 0x44/refile-to (file headline)
  (let ((pos (save-excursion
               (find-file file)
               (org-find-exact-headline-in-buffer headline))))
    (if pos
        (org-refile nil nil (list headline file nil pos))
        (message (format "Headline [%s] does not exist" headline)))))

(defun 0x44/recreate-project-tree (tree)
  (setq heading "*")
  (while tree
    (print (format "%s %s" heading (pop tree)))
    (setq heading (concat heading "*"))))

(defun 0x44/map-project-tree ()
  (org-refile nil nil '("Headline" "file" nil 1))
  (0x44/recreate-project-tree (0x44/crawl-project-tree)))
#+end_src

**** org-agenda refile
#+begin_src emacs-lisp :tangle yes
(after! org-agenda
  (setq org-refile-targets (quote ((nil :maxlevel . 9)
                                   (org-agenda-files :maxlevel . 9)))
        org-refile-use-outline-path t
        org-outline-path-complete-in-steps nil
        org-refile-allow-creating-parent-nodes (quote confirm))
(defun 0x44/org-refile-verify-target ()
  "Exclude DONE state tasks from refile targets"
  (not (member (nth 2 (org-heading-components)) org-done-keywords))))
#+end_src

**** org-agenda review
#+begin_src emacs-lisp :tangle yes
(defun 0x44/org-agenda-review-item ()
  "Review items in org-agenda"
  (interactive)
  (org-with-wide-buffer
   ;; (org-todo) ;; Need a different command for updating task states in org-agenda
   (org-agenda-set-tags)
   (org-agenda-priority)
   (org-agenda-set-effort)
   (org-agenda-refile nil nil t)))

(map! :map org-agenda-mode-map
      "R" #'0x44/org-agenda-review-item)
#+end_src

* Other Packages
** hl-todo
*** hl-todo faces
#+begin_src emacs-lisp
;; Set keywords and colors for hl-todo
;; A lot of these are right out of the src, just putting them here to document all keywords
 (setq hl-todo-keyword-faces
  '(("HOLD" . "#d0bf8f")
    ("TODO" . "#cc9393")
    ("NEXT" . "#dca3a3")
    ("THEM" . "#dc8cc3")
    ("PROG" . "#7cb8bb")
    ("OKAY" . "#7cb8bb")
    ("DONT" . "#5f7f5f")
    ("FAIL" . "#8c5353")
    ("DONE" . "#afd8af")
    ("CAND" . "#3d2f2f")
    ("NOTE"   . "#d0bf8f")
    ("KLUDGE" . "#d0bf8f")
    ("HACK"   . "#d0bf8f")
    ("TEMP"   . "#d0bf8f")
    ("FIXME"  . "#cc9393")
    ("XXX+"   . "#cc9393"))
  )
#+end_src

** tree-sitter
Better AST parsing and syntax highlighting!
#+begin_src emacs-lisp :tangle "packages.el"
(package! tree-sitter)
(package! tree-sitter-langs)
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! tree-sitter
  :hook
  (prog-mode . global-tree-sitter-mode)
  :config
  (require 'tree-sitter-langs)
  (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode))
#+end_src

** kubernetes-el
#+begin_src emacs-lisp :tangle "packages.el"
;; (package! kubernetes)
;; (package! kubernetes-evil)
#+end_src
#+begin_src emacs-lisp :tangle yes
;; (use-package! kubernetes
;;   :commands (kubernetes-overview))
;; (use-package! kubernetes-evil
;;   :after kubernetes)
#+end_src

** company-posframe
#+begin_src emacs-lisp :tangle "packages.el"
(package! company-posframe)
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! company-posframe
  :config
  (require 'company-posframe)
  (company-posframe-mode 1))
#+end_src

** git-link
#+begin_src emacs-lisp :tangle "packages.el"
(package! git-link)
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! git-link
  :commands
  (git-link git-link-commit git-link-homepage)
  :custom
  (git-link-use-commit 1))
#+end_src

** easy-kill
#+begin_src emacs-lisp :tangle "packages.el"
(package! easy-kill)
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! easy-kill
  :bind*
  (([remap kill-ring-save] . easy-kill)))
#+end_src
** calfw
We need to define our own function for opening the calfw calendar with sources.

#+begin_src emacs-lisp
(defun calendar-helper ()
  (cfw:open-calendar-buffer
   :contents-sources
   (list
    (cfw:org-create-source "Orange")
    (cfw:ical-create-source "ProtonCalendar" (+pass-get-secret "ics/protonmail") "Purple")
    (cfw:ical-create-source "HBHold" (+pass-get-secret "ics/hbhold") "Blue")
    )))
#+end_src

This stuff is some helper stuff to open the calendar into a workspace called 'calendar'.
#+begin_src emacs-lisp
(defun =my-calendar ()
  "Activate (or switch to) /my/ calendar in it's workspace."
  (interactive)
  (if (modulep! :ui workspaces)
      (progn
        (+workspace-switch "calendar" t)
        (doom/switch-to-scratch-buffer)
        (calendar-init)
        (+workspace/display))
    (setq +calendar--wconf (current-window-configuration))
    (delete-other-windows)
    (switch-to-buffer (doom-fallback-buffer))
    (calendar-init)))

(defun calendar-init ()
  (if-let (win (cl-find-if (lambda (b) (string-match-p "^\\*cfw:" (buffer-name b)))
                           (doom-visible-windows)
                           :key #'window-buffer))
      (select-window win)
    (calendar-helper)))

#+end_src
** mu4e-dashboard-mode
** Custom Packages
*** hammerspoon.el
This just loads the ~hammerspoon.el~ code needed to get the editWithEmacs Spoon
working.
#+begin_src emacs-lisp
(let ((hammerspoon-module "~/.hammerspoon/Spoons/editWithEmacs.spoon/hammerspoon.el"))
  (when (file-exists-p hammerspoon-module)
    (load hammerspoon-module)))
#+end_src
